--! @file        ebm_auto.vhd
--  DesignUnit   ebm_auto
--! @author      M. Kreider <>
--! @date        10/12/2015
--! @version     0.2.0
--! @copyright   2015 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE CORE FOR ebm.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify ebm.xml and re-run 'python wbgenplus.py ebm.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.matrix_pkg.all;
use work.genram_pkg.all;
use work.ebm_auto_pkg.all;

entity ebm_auto is
Port(
   clk_sys_i      : std_logic;                           -- Clock input for sys domain
   rst_sys_n_i    : std_logic;                           -- Reset input (active low) for sys domain
   slave_stall_i  : in  std_logic_vector(1-1 downto 0);  -- flow control
   status_i       : in  std_logic_vector(32-1 downto 0); -- Status. 31..16: Packet counter. b2: Error b1: busy b0: configured
   adr_hi_o       : out std_logic_vector(32-1 downto 0); -- High Address bits inserted into WB operations
   clear_o        : out std_logic_vector(1-1 downto 0);  -- Clears EBM buffers
   dst_ip_o       : out std_logic_vector(32-1 downto 0); -- Destination IPV4 address
   dst_mac_o      : out std_logic_vector(48-1 downto 0); -- Destination MAC address
   dst_port_o     : out std_logic_vector(16-1 downto 0); -- Destination port number
   eb_opt_o       : out std_logic_vector(32-1 downto 0); -- Default Record Header Options for current transaction
   flush_o        : out std_logic_vector(1-1 downto 0);  -- Send stored data as an EB packet
   mtu_o          : out std_logic_vector(16-1 downto 0); -- Maximum packet size
   sema_o         : out std_logic_vector(32-1 downto 0); -- Semaphore register in case multiple users want access
   src_ip_o       : out std_logic_vector(32-1 downto 0); -- Source IPV4 address
   src_mac_o      : out std_logic_vector(48-1 downto 0); -- Source MAC address
   src_port_o     : out std_logic_vector(16-1 downto 0); -- Source port number
   udp_data_o     : out std_logic_vector(16-1 downto 0); -- Raw udp Data input
   udp_data_WR_o  : out std_logic_vector(1-1 downto 0);  -- Write enable flag
   udp_raw_o      : out std_logic_vector(1-1 downto 0);  -- If this Flag is set, you can create raw udp packets by writing to udp_data
   
   slave_i        : in  t_wishbone_slave_in;
   slave_o        : out t_wishbone_slave_out

   
);
end ebm_auto;

architecture rtl of ebm_auto is

   signal r_slave_stall    : std_logic_vector(1-1 downto 0);   -- flow control
   signal s_slave_stall_i  : std_logic_vector(1-1 downto 0);   -- flow control
   signal r_clear          : std_logic_vector(1-1 downto 0);   -- Clears EBM buffers
   signal r_flush          : std_logic_vector(1-1 downto 0);   -- Send stored data as an EB packet
   signal r_status         : std_logic_vector(32-1 downto 0);  -- Status. 31..16: Packet counter. b2: Error b1: busy b0: configured
   signal s_status_i       : std_logic_vector(32-1 downto 0);  -- Status. 31..16: Packet counter. b2: Error b1: busy b0: configured
   signal r_src_mac        : std_logic_vector(48-1 downto 0);  -- Source MAC address
   signal r_src_ip         : std_logic_vector(32-1 downto 0);  -- Source IPV4 address
   signal r_src_port       : std_logic_vector(16-1 downto 0);  -- Source port number
   signal r_dst_mac        : std_logic_vector(48-1 downto 0);  -- Destination MAC address
   signal r_dst_ip         : std_logic_vector(32-1 downto 0);  -- Destination IPV4 address
   signal r_dst_port       : std_logic_vector(16-1 downto 0);  -- Destination port number
   signal r_mtu            : std_logic_vector(16-1 downto 0);  -- Maximum packet size
   signal r_adr_hi         : std_logic_vector(32-1 downto 0);  -- High Address bits inserted into WB operations
   signal r_eb_opt         : std_logic_vector(32-1 downto 0);  -- Default Record Header Options for current transaction
   signal r_sema           : std_logic_vector(32-1 downto 0);  -- Semaphore register in case multiple users want access
   signal r_udp_raw        : std_logic_vector(1-1 downto 0);   -- If this Flag is set, you can create raw udp packets by writing to udp_data
   signal r_udp_data_WR    : std_logic_vector(1-1 downto 0);   -- Write enable flag
   signal r_udp_data       : std_logic_vector(16-1 downto 0);  -- Raw udp Data input


begin

   s_slave_stall_i   <= slave_stall_i;
   slave_o.stall     <= r_slave_stall(0);
   clear_o           <= r_clear;
   flush_o           <= r_flush;
   s_status_i        <= status_i;
   src_mac_o         <= r_src_mac;
   src_ip_o          <= r_src_ip;
   src_port_o        <= r_src_port;
   dst_mac_o         <= r_dst_mac;
   dst_ip_o          <= r_dst_ip;
   dst_port_o        <= r_dst_port;
   mtu_o             <= r_mtu;
   adr_hi_o          <= r_adr_hi;
   eb_opt_o          <= r_eb_opt;
   sema_o            <= r_sema;
   udp_raw_o         <= r_udp_raw;
   udp_data_WR_o     <= r_udp_data_WR;
   udp_data_o        <= r_udp_data;
   slave : process(clk_sys_i)
      variable v_d : t_wishbone_data;
      variable v_a  : natural;
      variable v_p  : natural;
      variable v_s  : t_wishbone_byte_select;
      variable v_w  : std_logic;
      variable v_e  : std_logic;
   begin
      if rising_edge(clk_sys_i) then
         if(rst_sys_n_i = '0') then
            r_slave_stall  <= std_logic_vector(to_unsigned(0, 1));
            r_clear        <= (others => '0');
            r_flush        <= (others => '0');
            r_status       <= (others => '0');
            r_src_mac      <= x"d15ea5edbabe";
            r_src_ip       <= x"deadbeef";
            r_src_port     <= x"ebd0";
            r_dst_mac      <= x"ffffffffffff";
            r_dst_ip       <= x"ffffffff";
            r_dst_port     <= x"ebd0";
            r_mtu          <= std_logic_vector(to_unsigned(1500, 16));
            r_adr_hi       <= (others => '0');
            r_eb_opt       <= (others => '0');
            r_sema         <= (others => '0');
            r_udp_raw      <= (others => '0');
            r_udp_data_WR  <= std_logic_vector(to_unsigned(0, 1));
            r_udp_data     <= (others => '0');
         else
            slave_o.ack  <= '0';
            slave_o.err  <= '0';
            slave_o.dat  <= (others => '0');
         
            -- short names
            v_d := slave_i.dat;
            v_a := to_integer(unsigned(slave_i.adr(5 downto 2)) & "00");
            v_s := slave_i.sel;
            v_w := slave_i.we;
            v_e := slave_i.cyc and slave_i.stb and (not r_slave_stall(0));

            r_slave_stall  <= r_slave_stall and s_slave_stall_i;  -- extend stall if requested by outer entity
            r_clear        <= (others => '0');
            r_flush        <= (others => '0');
            r_status       <= s_status_i;
            r_udp_data_WR  <= (others => '0');
            
            if(v_e = '1') then
               slave_o.ack  <= '1';
               if(v_w = '1') then
                  -- WISHBONE WRITE ACTIONS
                  case v_a is
                     when c_clear_OWR           => r_clear                 <= f_wb_wr(r_clear,                 v_d, v_s, "owr"); -- 
                     when c_flush_OWR           => r_flush                 <= f_wb_wr(r_flush,                 v_d, v_s, "owr"); -- 
                     when c_src_mac_RW_0        => r_src_mac(31 downto 0)  <= f_wb_wr(r_src_mac(31 downto 0),  v_d, v_s, "owr"); -- 
                     when c_src_mac_RW_1        => r_src_mac(47 downto 32) <= f_wb_wr(r_src_mac(47 downto 32), v_d, v_s, "owr"); -- 
                     when c_src_ip_RW           => r_src_ip                <= f_wb_wr(r_src_ip,                v_d, v_s, "owr"); -- 
                     when c_src_port_RW         => r_src_port              <= f_wb_wr(r_src_port,              v_d, v_s, "owr"); -- 
                     when c_dst_mac_RW_0        => r_dst_mac(31 downto 0)  <= f_wb_wr(r_dst_mac(31 downto 0),  v_d, v_s, "owr"); -- 
                     when c_dst_mac_RW_1        => r_dst_mac(47 downto 32) <= f_wb_wr(r_dst_mac(47 downto 32), v_d, v_s, "owr"); -- 
                     when c_dst_ip_RW           => r_dst_ip                <= f_wb_wr(r_dst_ip,                v_d, v_s, "owr"); -- 
                     when c_dst_port_RW         => r_dst_port              <= f_wb_wr(r_dst_port,              v_d, v_s, "owr"); -- 
                     when c_mtu_RW              => r_mtu                   <= f_wb_wr(r_mtu,                   v_d, v_s, "owr"); -- 
                     when c_adr_hi_RW           => r_adr_hi                <= f_wb_wr(r_adr_hi,                v_d, v_s, "owr"); -- 
                     when c_eb_opt_RW           => r_eb_opt                <= f_wb_wr(r_eb_opt,                v_d, v_s, "owr"); -- 
                     when c_sema_RW             => r_sema                  <= f_wb_wr(r_sema,                  v_d, v_s, "owr"); -- 
                     when c_udp_raw_RW          => r_udp_raw               <= f_wb_wr(r_udp_raw,               v_d, v_s, "owr"); -- 
                     when c_udp_data_OWR        => r_udp_data              <= f_wb_wr(r_udp_data,              v_d, v_s, "owr"); -- 
                     r_udp_data_WR                                         <= (others   => '1');
                     when others => slave_o.ack <= '0'; slave_o.err <= '1';
                  end case;
               else
                  -- WISHBONE READ ACTIONS
                  case v_a is
                     when c_status_GET    => slave_o.dat(31 downto 0)   <= r_status;                  -- 
                     when c_src_mac_RW_0  => slave_o.dat(31 downto 0)   <= r_src_mac(31 downto 0);    -- 
                     when c_src_mac_RW_1  => slave_o.dat(15 downto 0)   <= r_src_mac(47 downto 32);   -- 
                     when c_src_ip_RW     => slave_o.dat(31 downto 0)   <= r_src_ip;                  -- 
                     when c_src_port_RW   => slave_o.dat(15 downto 0)   <= r_src_port;                -- 
                     when c_dst_mac_RW_0  => slave_o.dat(31 downto 0)   <= r_dst_mac(31 downto 0);    -- 
                     when c_dst_mac_RW_1  => slave_o.dat(15 downto 0)   <= r_dst_mac(47 downto 32);   -- 
                     when c_dst_ip_RW     => slave_o.dat(31 downto 0)   <= r_dst_ip;                  -- 
                     when c_dst_port_RW   => slave_o.dat(15 downto 0)   <= r_dst_port;                -- 
                     when c_mtu_RW        => slave_o.dat(15 downto 0)   <= r_mtu;                     -- 
                     when c_adr_hi_RW     => slave_o.dat(31 downto 0)   <= r_adr_hi;                  -- 
                     when c_eb_opt_RW     => slave_o.dat(31 downto 0)   <= r_eb_opt;                  -- 
                     when c_sema_RW       => slave_o.dat(31 downto 0)   <= r_sema;                    -- 
                     when c_udp_raw_RW    => slave_o.dat(0 downto 0)    <= r_udp_raw;                 -- 
                     when others => slave_o.ack <= '0'; slave_o.err <= '1';
                  end case;
               end if; -- v_w
            end if; -- v_e
         end if; -- rst
      end if; -- clk edge
   end process;

end rtl;
